<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Garden - Animated Flowers (Fixed Shaders)</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/js/controls/DeviceOrientationControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gwendolyn:wght@700&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* --- CSS styles remain the same --- */
        body { margin: 0; padding: 0; font-family: 'Roboto', Arial, sans-serif; overflow: hidden; background-color: #000; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 3000; text-align: center; padding: 20px; box-sizing: border-box; }
        #loading h1 { font-family: 'Roboto', sans-serif; font-weight: 700; font-size: 2.5em; margin-bottom: 15px; }
        #loading p { font-size: 1.1em; margin-bottom: 20px; }
        #camera-feed { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #css2d-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; }
        .css2d-interactive { pointer-events: auto; }
        #message-container { color: white; background: none; padding: 5px; text-align: center; font-family: 'Gwendolyn', cursive; font-weight: 700; font-size: 30vw; line-height: 1.1; pointer-events: auto; text-shadow: 1px 1px 2px rgba(0,0,0,0.7), 2px 2px 5px rgba(0,0,0,0.5); white-space: normal; max-width: 90%; box-sizing: border-box; }
        .dynamic-response-display { color: #C8FFC5; background-color: rgba(0,0,0,0.65); padding: 8px 12px; border-radius: 8px; text-align: center; font-family: 'Roboto', sans-serif; font-size: 15px; font-weight: 400; pointer-events: auto; max-width: 250px; box-sizing: border-box; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); }
        .controls { position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: space-around; padding: 0 20px; box-sizing: border-box; z-index: 100; }
        .btn { width: 60px; height: 60px; border-radius: 50%; color: white; border: none; font-family: 'Roboto', sans-serif; font-size: 28px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.4); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; }
        #place-btn { background-color: #4CAF50; }
        #reset-btn { background-color: #f44336; display: none; }
        #response-toggle { background-color: #2196F3; display: none; }
        #response-form { position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; background: rgba(20,20,20,0.85); backdrop-filter: blur(5px); border-radius: 15px; padding: 20px; color: white; z-index: 200; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #response-form input, #response-form textarea { width: calc(100% - 20px); padding: 10px; margin: 8px 0 12px; border: 1px solid #555; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; font-size: 16px; }
        #response-form textarea { height: 80px; resize: none; }
        #response-form button { background: #4CAF50; color: white; border: none; padding: 12px 18px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; font-size: 16px; }
        #response-form h3 { margin-top: 0; text-align: center; font-weight: 700;}
        #response-status { margin-top: 12px; text-align: center; font-weight: bold; min-height: 20px; }
        #instructions { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); backdrop-filter: blur(3px); color: white; padding: 12px 18px; border-radius: 10px; text-align: center; font-size: 16px; z-index: 100; max-width: 80%; }
        #permission-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 20px; }
        #permission-overlay h2 { font-weight: 700; }
        #permission-btn { margin-top: 20px; padding: 12px 24px; background-color: #4CAF50; color: white; border: none; border-radius: 30px; font-size: 18px; font-weight: 700; cursor: pointer; }
        #debug-info { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 8px 12px; border-radius: 5px; font-size: 11px; font-family: monospace; z-index: 2500; display: none; width: calc(100% - 40px); max-height: 150px; overflow-y: auto; }
    </style>

    <script id="flowerVertexShader" type="x-shader/x-vertex">
// REMOVED: #version, precision - Three.js provides these

// Standard uniforms provided by Three.js (DO NOT redeclare)
// uniform mat4 modelViewMatrix;
// uniform mat4 projectionMatrix;

// Custom uniforms (declare ONLY these)
uniform float u_time;

// Standard attributes provided by Three.js (DO NOT redeclare)
// in vec3 position;
// in vec2 uv;
// in vec3 normal; // If needed

// Custom instanced attributes (declare ONLY these)
in vec2 instanceRandomVec2;      // x: random1 (0-1), y: random2 (0-1) for variations
in float instanceStemGrowTime;   // Normalized 0.0 (start) to 1.0 (fully grown)
in float instanceFlowerGrowTime; // Normalized 0.0 (start) to 1.0 (fully bloomed)

// Varyings to pass to fragment shader (declare these)
out vec2 vUv;
out float vTime;
out vec2 vRandomVec2;
out float vStemGrowTime;
out float vFlowerGrowTime;
out float vFragDepth;

void main() {
    // Read standard attributes (uv, position) provided by Three.js
    vUv = uv;
    vTime = u_time; // Pass custom uniform
    
    // Read custom attributes
    vRandomVec2 = instanceRandomVec2;
    vStemGrowTime = instanceStemGrowTime;
    vFlowerGrowTime = instanceFlowerGrowTime;

    vec3 pos = position; // Use standard 'position' attribute

    // Gentle sway animation
    float wiggleFactor = vStemGrowTime * (0.03 + vRandomVec2.x * 0.03);
    pos.x += sin(vTime * (0.8 + vRandomVec2.y * 0.4) + pos.y * 0.6) * wiggleFactor;
    pos.y += cos(vTime * (0.7 + vRandomVec2.x * 0.3) + pos.x * 0.4) * wiggleFactor * 0.7;

    // Use standard uniforms (modelViewMatrix, projectionMatrix) provided by Three.js
    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;
    
    vFragDepth = gl_Position.z / gl_Position.w;
}
    </script>

    <script id="flowerFragmentShader" type="x-shader/x-fragment">
// REMOVED: #version, precision - Three.js provides these

// Custom uniforms (declare ONLY these, if needed in FS directly)
// uniform float u_time; // Available, but vTime varying is used here

// Varyings received from vertex shader (declare these)
in vec2 vUv;
in float vTime;
in vec2 vRandomVec2;
in float vStemGrowTime;
in float vFlowerGrowTime;
// in float vFragDepth; // Available if needed

// Standard fragment output provided by Three.js (DO NOT redeclare)
// out vec4 pc_fragColor; 
// Use the define below to use 'gl_FragColor' name like in WebGL 1
#define gl_FragColor pc_fragColor

// Constants
#define PI 3.14159265359
#define TWO_PI 6.28318530718

// SDF functions (Helper functions are fine)
float sdfCircle(vec2 p, float r) {
    return length(p) - r;
}
float sdfBox(vec2 p, vec2 b) {
    vec2 d = abs(p) - b;
    return length(max(d, vec2(0.0))) + min(max(d.x, d.y), 0.0);
}
vec2 rotate(vec2 p, float angle) {
    float s = sin(angle);
    float c = cos(angle);
    return mat2(c, -s, s, c) * p;
}

void main() {
    // Center UV coordinates
    vec2 uv = vUv - 0.5;

    vec3 finalColor = vec3(0.0);
    float finalAlpha = 0.0;

    // --- Stem ---
    vec3 stemColor = vec3(0.25 + vRandomVec2.x * 0.1, 0.45 + vRandomVec2.x * 0.1, 0.1 + vRandomVec2.x * 0.05);
    float stemWidth = 0.025 + vRandomVec2.y * 0.01;
    float stemBaseY = -0.1;
    float stemMaxVisualHeight = 0.5 + stemBaseY;
    float currentStemVisualHeight = vStemGrowTime * stemMaxVisualHeight;
    float stemCenterY = -0.5 + currentStemVisualHeight / 2.0;
    float stemSDF = sdfBox(vec2(uv.x, uv.y - stemCenterY), vec2(stemWidth, currentStemVisualHeight / 2.0));
    float stemAlpha = smoothstep(0.005, 0.0, stemSDF) * vStemGrowTime;

    if (stemAlpha > 0.01) {
        finalColor = mix(finalColor, stemColor, stemAlpha);
        finalAlpha = max(finalAlpha, stemAlpha);
    }

    // --- Flower ---
    if (vStemGrowTime > 0.6) {
        float bloomProgress = vFlowerGrowTime;
        vec2 flowerCenterPos = vec2(0.0, stemBaseY + 0.02 * bloomProgress);
        vec3 petalColor1 = vec3(0.85 + vRandomVec2.x * 0.15, 0.3 + vRandomVec2.y * 0.2, 0.4 + vRandomVec2.x * 0.1);
        vec3 petalColor2 = vec3(0.9, 0.4 + vRandomVec2.x * 0.2, 0.5 + vRandomVec2.y * 0.15);
        vec3 flowerCoreColor = vec3(0.95, 0.85, 0.3);
        int numPetals = int(5.0 + vRandomVec2.x * 2.9);
        float petalLength = (0.12 + vRandomVec2.y * 0.05) * bloomProgress;
        float petalWidth = (petalLength * 0.6) * (0.8 + vRandomVec2.x * 0.2);
        float petalSharpness = 0.005;
        float minPetalSDF = 10.0;

        for (int i = 0; i < numPetals; i++) {
            float anglePerPetal = TWO_PI / float(numPetals);
            float baseAngle = anglePerPetal * float(i) + vRandomVec2.y * PI * 0.2;
            float unfurlAngle = (1.0 - bloomProgress * bloomProgress) * (PI / 3.0) * (mod(float(i), 2.0) - 0.5) * 2.0;
            float currentPetalAngle = baseAngle + unfurlAngle;
            vec2 petalInstanceCenter = flowerCenterPos + vec2(cos(currentPetalAngle), sin(currentPetalAngle)) * (petalLength * 0.55);
            vec2 p_local = rotate(uv - petalInstanceCenter, -currentPetalAngle);
            float sdf = sdfCircle(p_local / vec2(petalWidth, petalLength) , 0.5);
            minPetalSDF = min(minPetalSDF, sdf);
        }
        float petalsAlpha = smoothstep(petalSharpness, 0.0, minPetalSDF) * bloomProgress;

        float coreRadius = (0.03 + vRandomVec2.x * 0.015) * bloomProgress;
        float coreSDF = sdfCircle(uv - flowerCenterPos, coreRadius);
        float coreAlpha = smoothstep(0.005, 0.0, coreSDF) * bloomProgress;

        if (petalsAlpha > 0.01) {
            vec3 currentPetalColor = mix(petalColor1, petalColor2, 0.5 + 0.5 * sin(float(numPetals) * vRandomVec2.y + vTime * 0.5));
            finalColor = mix(finalColor, currentPetalColor, petalsAlpha / (finalAlpha + petalsAlpha + 0.001) );
            finalAlpha = max(finalAlpha, petalsAlpha);
        }
        if (coreAlpha > 0.01) {
            finalColor = mix(finalColor, flowerCoreColor, coreAlpha / (finalAlpha + coreAlpha + 0.001) );
            finalAlpha = max(finalAlpha, coreAlpha);
        }
    }

    if (finalAlpha < 0.01) {
        discard;
    }

    // Use the automatically provided output variable via the #define
    gl_FragColor = vec4(finalColor, finalAlpha); 
}
    </script>
</head>

<body>
    <div id="loading"><h1>Why can't...?</h1><p>Loading experience...</p></div>
    <div id="permission-overlay"><h2>Motion Sensors Required</h2><p>This AR experience needs access to your device's motion sensors to look around.</p><button id="permission-btn">Allow Motion Sensors</button></div>
    <video id="camera-feed" autoplay playsinline muted></video>
    <div id="canvas-container"></div>
    <div id="message-container" style="display: none;"><p id="message-text">Why can't this be a community garden?</p></div>
    <div id="response-display-template" style="display: none;"><div class="dynamic-response-display"></div></div>
    <div id="instructions">Tap ðŸŒ¸ to experience the garden, then look around.</div>
    <div class="controls"><button id="response-toggle" class="btn" title="Share thoughts">+</button><button id="place-btn" class="btn" title="Place Garden">ðŸŒ¸</button><button id="reset-btn" class="btn" title="Reset Garden">â†º</button></div>
    <div id="response-form"><h3>Share Your Thoughts</h3><form id="garden-response-form"><label for="name">Your Name:</label><input type="text" id="name" name="name" placeholder="e.g., Alex P." required><label for="form-message">Why can't this be a community garden?</label><textarea id="form-message" name="message" placeholder="Your ideas..." required></textarea><button type="submit">Submit Idea</button></form><div id="response-status"></div></div>
    <div id="debug-info"></div>

    <script type="module">
        // --- All JavaScript code remains the same as the previous version ---
        document.addEventListener('DOMContentLoaded', function () {
            console.log("DOM Content Loaded - Debugging UI & Responses V2 - Fixed Shaders");

            let debugInfo = null;
            const loadingScreen = document.getElementById('loading');
            const permissionOverlay = document.getElementById('permission-overlay');
            const permissionBtn = document.getElementById('permission-btn');
            const cameraFeed = document.getElementById('camera-feed');
            const canvasContainer = document.getElementById('canvas-container');
            const instructions = document.getElementById('instructions');
            const placeBtn = document.getElementById('place-btn');
            const resetBtn = document.getElementById('reset-btn');
            const responseToggle = document.getElementById('response-toggle');
            const responseFormParent = document.getElementById('response-form');
            const messageElement = document.getElementById('message-container'); 

            debugInfo = document.getElementById('debug-info');

            let scene, camera, renderer, controls, css2dRenderer, clock;
            let messageObject; 
            let activeResponseObjects = []; 
            const MAX_VISIBLE_RESPONSES = 4;
            let isPlaced = false;

            let instancedFlowers;
            const MAX_FLOWERS = 2500; 
            let currentFlowerCount = 0; 

            let instanceStemGrowTimes = new Float32Array(MAX_FLOWERS);
            let instanceFlowerGrowTimes = new Float32Array(MAX_FLOWERS);
            let instanceRandomVec2s = new Float32Array(MAX_FLOWERS * 2); 
            let instanceStemGrowDuration = new Float32Array(MAX_FLOWERS); 
            let instanceFlowerGrowDuration = new Float32Array(MAX_FLOWERS); 
            let instanceIsBlooming = new Array(MAX_FLOWERS).fill(false); 
            
            const dummy = new THREE.Object3D(); 

            const urlParams = new URLSearchParams(window.location.search);
            const debugMode = urlParams.has('debug');

            if (debugMode) { if (debugInfo) debugInfo.style.display = 'block'; else console.warn("debugInfo element not found for overlay."); }
            else { if (debugInfo) debugInfo.style.display = 'none'; }

            function simpleLog(message) { if (debugMode && debugInfo) { debugInfo.innerHTML += message + '<br>'; debugInfo.scrollTop = debugInfo.scrollHeight; } console.log("SLOG:", message); }
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

            simpleLog("About to call initAR()");
            initAR();

            function initAR() { /* ... same as before ... */
                simpleLog('initAR: Called');
                startCamera();
                if (isIOS && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    simpleLog("initAR: iOS path - requesting motion sensor permission.");
                    permissionOverlay.style.display = 'flex';
                    permissionBtn.addEventListener('click', requestMotionPermission, { once: true });
                } else {
                    simpleLog("initAR: Non-iOS or permission not needed / already granted path.");
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    initThree();
                }
            }
            function requestMotionPermission() { /* ... same as before ... */
                 simpleLog("requestMotionPermission: Called");
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        simpleLog("requestMotionPermission: GRANTED");
                        permissionOverlay.style.display = 'none';
                        if (loadingScreen) loadingScreen.style.display = 'none';
                        initThree();
                    } else {
                        simpleLog("requestMotionPermission: DENIED");
                        alert('Motion sensor access is required for this AR experience. Please reload and grant permission.');
                        if (loadingScreen) loadingScreen.innerHTML = '<p>Motion sensor access denied. Please reload the page and grant permission.</p>';
                    }
                }).catch(error => {
                    console.error('requestMotionPermission: ERROR', error);
                    alert('An error occurred while requesting motion sensor access.');
                    if (loadingScreen) loadingScreen.innerHTML = '<p>Error requesting motion sensors. Please reload.</p>';
                });
            }
            function startCamera() { /* ... same as before ... */
                 simpleLog("startCamera: Called");
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Camera access is not supported by your browser.');
                    if (loadingScreen) loadingScreen.innerHTML = '<p>Camera not supported.</p>';
                    simpleLog("startCamera: Camera access not supported.");
                    return;
                }
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: window.innerWidth }, height: { ideal: window.innerHeight } } })
                    .then(stream => {
                        simpleLog("startCamera: getUserMedia SUCCEEDED");
                        cameraFeed.srcObject = stream;
                        cameraFeed.onloadedmetadata = () => {
                            simpleLog('startCamera: Camera feed active and playing.');
                            cameraFeed.play();
                        };
                    }).catch(err => {
                        simpleLog("startCamera: getUserMedia FAILED: " + err.message);
                        console.error('startCamera: ERROR:', err);
                        alert("Could not access the camera: " + err.message + ". Please check browser permissions and reload.");
                        if (loadingScreen) loadingScreen.innerHTML = '<p>Camera access failed. Please check permissions and reload.</p>';
                    });
            }

            function initThree() { /* ... same as before, relies on corrected shaders ... */
                 simpleLog("initThree: START");
                try {
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(0, 1.6, 0); 

                    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setClearColor(0x000000, 0); 
                    canvasContainer.appendChild(renderer.domElement);

                    css2dRenderer = new THREE.CSS2DRenderer();
                    css2dRenderer.setSize(window.innerWidth, window.innerHeight);
                    css2dRenderer.domElement.id = 'css2d-container'; 
                    document.body.appendChild(css2dRenderer.domElement);


                    controls = new THREE.DeviceOrientationControls(camera);
                    clock = new THREE.Clock();

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); 
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); 
                    directionalLight.position.set(1, 3, 2);
                    scene.add(directionalLight);

                    const baseFlowerGeometry = createBaseFlowerGeometry(); 
                    const baseFlowerMaterial = createBaseFlowerMaterial(); // <<< This uses the corrected shaders now
                    
                    instancedFlowers = new THREE.InstancedMesh(baseFlowerGeometry, baseFlowerMaterial, MAX_FLOWERS);
                    instancedFlowers.instanceMatrix.setUsage(THREE.DynamicDrawUsage); 

                    instancedFlowers.geometry.setAttribute('instanceRandomVec2', new THREE.InstancedBufferAttribute(instanceRandomVec2s, 2));
                    instancedFlowers.geometry.setAttribute('instanceStemGrowTime', new THREE.InstancedBufferAttribute(instanceStemGrowTimes, 1));
                    instancedFlowers.geometry.setAttribute('instanceFlowerGrowTime', new THREE.InstancedBufferAttribute(instanceFlowerGrowTimes, 1));
                    
                    instancedFlowers.count = 0; 
                    scene.add(instancedFlowers);
                    simpleLog("initThree: InstancedFlowers mesh created: " + (!!instancedFlowers));

                    createCSS2DObjects(); 
                    window.addEventListener('resize', onWindowResize);
                    animate();
                    simpleLog("initThree: COMPLETED SUCCESSFULLY");

                } catch (error) {
                    console.error("initThree: CRITICAL ERROR:", error);
                    simpleLog("initThree: CRITICAL ERROR: " + error.message);
                    alert("A critical error occurred setting up the 3D scene: " + error.message);
                }
            }
            function createBaseFlowerGeometry() { /* ... same as before ... */
                const s = 1.8;
                return new THREE.PlaneGeometry(s, s); 
            }
            function createBaseFlowerMaterial() { /* ... same as before ... */
                 const uniforms = {
                    u_time: { value: 0.0 },
                };
                return new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('flowerVertexShader').textContent, // Reads corrected shader
                    fragmentShader: document.getElementById('flowerFragmentShader').textContent, // Reads corrected shader
                    transparent: true,
                    side: THREE.DoubleSide, 
                    depthWrite: false, 
                });
            }
            function createCSS2DObjects() { /* ... same as before ... */
                 simpleLog("createCSS2DObjects: Called");
                if (!messageElement) { console.error('CSS2DObjects: messageElement (for large text) not found!'); return; }
                
                messageObject = new THREE.CSS2DObject(messageElement);
                messageObject.position.set(0, 1.8, -4.0); 
                scene.add(messageObject);
                messageObject.visible = false; 
            }
            function placeFlowers() { /* ... same as before ... */
                simpleLog("placeFlowers: Called (InstancedMesh version)");
                if (!instancedFlowers) { console.error("placeFlowers: InstancedMesh not ready."); return; }

                currentFlowerCount = MAX_FLOWERS / 2; 
                simpleLog(`placeFlowers: Attempting to place ${currentFlowerCount} flowers.`);

                const minDistance = 1.5; const maxDistance = 18.0;
                const minHeight = -2.0; const maxHeight = 1.5; 

                instanceIsBlooming.fill(false);
                instanceStemGrowTimes.fill(0);
                instanceFlowerGrowTimes.fill(0);
                instanceRandomVec2s.fill(0);
                instanceStemGrowDuration.fill(1.0); 
                instanceFlowerGrowDuration.fill(2.0);


                for (let i = 0; i < currentFlowerCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = minDistance + Math.random() * (maxDistance - minDistance);
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const y = (camera.position.y - 1.6) + (minHeight + Math.random() * (maxHeight - minHeight));

                    dummy.position.set(x, y, z);
                    dummy.rotation.set(0, Math.random() * Math.PI * 2, 0); 
                    const scaleVariation = 0.5 + Math.random() * 0.7; 
                    dummy.scale.set(scaleVariation, scaleVariation, scaleVariation);
                    dummy.updateMatrix(); 
                    instancedFlowers.setMatrixAt(i, dummy.matrix);

                    instanceRandomVec2s[i * 2 + 0] = Math.random(); 
                    instanceRandomVec2s[i * 2 + 1] = Math.random(); 
                    
                    instanceStemGrowTimes[i] = 0.0;   
                    instanceFlowerGrowTimes[i] = 0.0; 

                    instanceStemGrowDuration[i] = 0.8 + Math.random() * 0.4; 
                    instanceFlowerGrowDuration[i] = instanceStemGrowDuration[i] + (0.7 + Math.random() * 0.6); 

                    setTimeout(() => {
                        if (i < instancedFlowers.count) { 
                           instanceIsBlooming[i] = true;
                        }
                    }, 100 + Math.random() * 2500); 
                }

                instancedFlowers.instanceMatrix.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceRandomVec2) instancedFlowers.geometry.attributes.instanceRandomVec2.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceStemGrowTime) instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceFlowerGrowTime) instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                
                instancedFlowers.count = currentFlowerCount; 
                simpleLog(`placeFlowers: Placed and set count for ${currentFlowerCount} flowers.`);
            }
            function removeFlowers() { /* ... same as before ... */
                 if (instancedFlowers) {
                    simpleLog(`removeFlowers: Hiding ${instancedFlowers.count} flowers by setting count to 0.`);
                    instancedFlowers.count = 0;
                    instancedFlowers.instanceMatrix.needsUpdate = true; 
                    
                    instanceIsBlooming.fill(false);
                    instanceStemGrowTimes.fill(0.0); 
                    instanceFlowerGrowTimes.fill(0.0);

                    if (instancedFlowers.geometry.attributes.instanceStemGrowTime) instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                    if (instancedFlowers.geometry.attributes.instanceFlowerGrowTime) instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;

                    currentFlowerCount = 0;
                }
            }
            function placeDynamicResponses() { /* ... same as before ... */
                 simpleLog("placeDynamicResponses: Called");
                if (!window.responses || window.responses.length === 0) {
                    simpleLog("placeDynamicResponses: No responses available to display.");
                    return;
                }
                removeDynamicResponses(); 

                const numToShow = Math.min(MAX_VISIBLE_RESPONSES, window.responses.length);
                const shuffledResponses = [...window.responses].sort(() => 0.5 - Math.random()); 
                simpleLog(`placeDynamicResponses: Preparing to show ${numToShow} responses.`);

                const responseTemplate = document.getElementById('response-display-template');
                if (!responseTemplate) {
                    console.error("placeDynamicResponses: response-display-template not found!");
                    simpleLog("placeDynamicResponses: ERROR - response-display-template not found!");
                    return;
                }

                for (let i = 0; i < numToShow; i++) {
                    const responseData = shuffledResponses[i];
                    const responseDiv = responseTemplate.firstElementChild.cloneNode(true); 
                    responseDiv.textContent = `"${responseData.message}" - ${responseData.name}`;
                    
                    const newResponseObject = new THREE.CSS2DObject(responseDiv);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 2.5 + Math.random() * 2.5; 
                    const responseX = Math.cos(angle) * distance;
                    const responseZ = Math.sin(angle) * distance;
                    const responseY = (camera.position.y - 0.5) + Math.random(); 

                    newResponseObject.position.set(responseX, responseY, responseZ);
                    newResponseObject.visible = true; 
                    scene.add(newResponseObject);
                    activeResponseObjects.push(newResponseObject);
                    simpleLog(`placeDynamicResponses: Created CSS2DObject for response "${responseData.message}"`);
                }
                simpleLog(`placeDynamicResponses: Displayed ${activeResponseObjects.length} responses.`);
            }
            function removeDynamicResponses() { /* ... same as before ... */
                 simpleLog(`removeDynamicResponses: Removing ${activeResponseObjects.length} dynamic response objects.`);
                activeResponseObjects.forEach(obj => {
                    if (obj.element && obj.element.parentNode) {
                        // obj.element.parentNode.removeChild(obj.element); 
                    }
                    scene.remove(obj); 
                });
                activeResponseObjects = [];
            }
            function updateFlowerAnimations(delta, elapsedTime) { /* ... same as before ... */
                if (!instancedFlowers || instancedFlowers.count === 0) return;

                instancedFlowers.material.uniforms.u_time.value = elapsedTime;

                let needsStemUpdate = false;
                let needsFlowerUpdate = false;

                for (let i = 0; i < instancedFlowers.count; i++) {
                    if (instanceIsBlooming[i]) { 
                        if (instanceStemGrowTimes[i] < 1.0) {
                            instanceStemGrowTimes[i] += delta / instanceStemGrowDuration[i];
                            instanceStemGrowTimes[i] = Math.min(instanceStemGrowTimes[i], 1.0);
                            needsStemUpdate = true;
                        }

                        if (instanceStemGrowTimes[i] >= 1.0 && instanceFlowerGrowTimes[i] < 1.0) {
                            let flowerPhaseDuration = instanceFlowerGrowDuration[i] - instanceStemGrowDuration[i];
                            if (flowerPhaseDuration <= 0) flowerPhaseDuration = delta; 

                            instanceFlowerGrowTimes[i] += delta / flowerPhaseDuration;
                            instanceFlowerGrowTimes[i] = Math.min(instanceFlowerGrowTimes[i], 1.0);
                            needsFlowerUpdate = true;
                        }
                    }
                }

                if (needsStemUpdate && instancedFlowers.geometry.attributes.instanceStemGrowTime) {
                    // Force update - Assign a value from the array back to itself (index 0 is arbitrary)
                    // This sometimes helps ensure the GPU sees the buffer update.
                    instancedFlowers.geometry.attributes.instanceStemGrowTime.array[0] = instanceStemGrowTimes[0]; 
                    instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                }
                if (needsFlowerUpdate && instancedFlowers.geometry.attributes.instanceFlowerGrowTime) {
                    // Force update
                    instancedFlowers.geometry.attributes.instanceFlowerGrowTime.array[0] = instanceFlowerGrowTimes[0]; 
                    instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                }
            }
            function animate() { /* ... same as before ... */
                 requestAnimationFrame(animate);
                if (controls) controls.update();
                if (!clock) return;

                const delta = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();

                if (isPlaced) {
                    updateFlowerAnimations(delta, elapsedTime); 

                    if (instancedFlowers && instancedFlowers.count > 0) {
                        const camPos = camera.position;
                        for (let i = 0; i < instancedFlowers.count; i++) {
                            instancedFlowers.getMatrixAt(i, dummy.matrix);
                            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                            dummy.lookAt(camPos); 
                            dummy.updateMatrix();
                            instancedFlowers.setMatrixAt(i, dummy.matrix);
                        }
                        instancedFlowers.instanceMatrix.needsUpdate = true;
                    }
                }
                
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                } else {
                    simpleLog("animate: renderer, scene, or camera missing!");
                }

                if (css2dRenderer && scene && camera) {
                    css2dRenderer.render(scene, camera);
                }
            }
            function onWindowResize() { /* ... same as before ... */
                if (camera && renderer && css2dRenderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    css2dRenderer.setSize(window.innerWidth, window.innerHeight);
                    simpleLog("onWindowResize: Updated camera and renderers.");
                }
            }
            
            // UI Listeners & Response Handling... same as before ...
            if (!placeBtn) { console.error("CRITICAL ERROR: placeBtn element not found!"); }
            else { /* ... placeBtn listener ... */ 
                simpleLog("Attaching listener to placeBtn.");
                placeBtn.addEventListener('click', function () {
                    simpleLog("placeBtn: CLICKED.");
                    if (isPlaced) { simpleLog(`placeBtn: Garden already placed.`); return; }
                    if (!instancedFlowers || !scene || !camera) {
                        console.error('placeBtn: CRITICAL - Prerequisite Three.js objects (instancedFlowers, scene, camera) not ready!');
                        simpleLog('placeBtn: ERROR - Prerequisite objects not ready!');
                        alert("The garden components are not ready yet. Please wait or reload.");
                        return;
                    }
                    
                    if (messageObject && messageObject.element) {
                        messageObject.visible = true;
                        messageElement.style.display = 'block'; 
                    } else {
                        simpleLog("placeBtn: messageObject or its element not ready to be shown.");
                    }

                    placeBtn.style.display = 'none';
                    resetBtn.style.display = 'flex';
                    responseToggle.style.display = 'flex';
                    instructions.style.display = 'none';
                    
                    placeFlowers(); 
                    isPlaced = true;
                    loadResponses(true); 
                    simpleLog('placeBtn: Garden PLACED with instanced flowers.');
                });
            }
            if (!resetBtn) { console.error("CRITICAL ERROR: resetBtn element not found!"); }
            else { /* ... resetBtn listener ... */ 
                simpleLog("Attaching listener to resetBtn.");
                resetBtn.addEventListener('click', function () {
                    simpleLog("resetBtn: CLICKED");
                    if (!isPlaced) { simpleLog("resetBtn: Nothing to reset, garden not placed."); return; }
                    
                    if (messageObject && messageObject.element) {
                        messageObject.visible = false;
                        messageElement.style.display = 'none';
                    }
                    removeDynamicResponses(); 
                    
                    resetBtn.style.display = 'none';
                    placeBtn.style.display = 'flex';
                    responseToggle.style.display = 'none';
                    if (responseFormParent) responseFormParent.style.display = 'none'; 
                    
                    instructions.style.display = 'block';
                    removeFlowers(); 
                    isPlaced = false;
                    simpleLog('resetBtn: Garden RESET.');
                });
            }
            if (!responseToggle) { console.error("CRITICAL ERROR: responseToggle element not found!"); }
            else { /* ... responseToggle listener ... */ 
                 simpleLog("Attaching listener to responseToggle.");
                responseToggle.addEventListener('click', function () {
                    simpleLog("responseToggle: CLICKED");
                    if (!responseFormParent) { console.error("responseToggle: responseFormParent (div#response-form) not found!"); return; }
                    const isFormVisible = responseFormParent.style.display === 'block';
                    responseFormParent.style.display = isFormVisible ? 'none' : 'block';
                    responseToggle.textContent = isFormVisible ? 'âœ•' : '+'; 
                    simpleLog(`responseToggle: Form display set to ${responseFormParent.style.display}`);
                });
            }
            
             window.responses = [ /* ... mock data ... */ 
                { name: "Gardener A", message: "More native plants, please!" },
                { name: "Bee Lover", message: "We need pollinator-friendly species." },
                { name: "Artist X", message: "A sculpture would look great here." },
                { name: "Kiddo", message: "Can we have a fairy garden part?" },
                { name: "Community Member", message: "A bench to sit would be nice." }
             ];
            function loadResponses(isInitialPlacement = false) { /* ... same as before ... */
                 simpleLog(`loadResponses: Called. isInitialPlacement: ${isInitialPlacement}`);
                if (isPlaced) { 
                    placeDynamicResponses();
                }
            }
            const gardenResponseForm = document.getElementById('garden-response-form');
            if (!gardenResponseForm) { console.error("CRITICAL ERROR: garden-response-form element not found!"); }
            else { /* ... form submit listener ... */ 
                gardenResponseForm.addEventListener('submit', function (e) {
                    e.preventDefault();
                    simpleLog("gardenResponseForm: SUBMITTED");
                    const nameInput = document.getElementById('name');
                    const messageInput = document.getElementById('form-message');
                    const statusDiv = document.getElementById('response-status');

                    if (!nameInput || !messageInput || !statusDiv) {
                        console.error("Form submission: Name, message input, or status div not found.");
                        simpleLog("Form submission: ERROR - form elements missing.");
                        return;
                    }

                    const name = nameInput.value.trim();
                    const message = messageInput.value.trim();

                    if (name && message) {
                        simpleLog(`Form data: Name: ${name}, Message: ${message}`);
                        window.responses.push({ name: name, message: message });
                        statusDiv.textContent = "Idea submitted! Thank you!";
                        statusDiv.style.color = "#4CAF50";
                        
                        nameInput.value = '';
                        messageInput.value = '';
                        if(isPlaced) placeDynamicResponses(); 

                        setTimeout(() => { 
                            statusDiv.textContent = ""; 
                            if (responseFormParent) responseFormParent.style.display = 'none'; 
                            responseToggle.textContent = '+';
                        }, 2500);
                    } else {
                        statusDiv.textContent = "Please fill out both fields.";
                        statusDiv.style.color = "#f44336";
                        simpleLog("Form submission: Fields not filled.");
                    }
                });
            }

            if (!isIOS || (isIOS && typeof DeviceOrientationEvent.requestPermission !== 'function')) { /* ... same as before ... */
                if (permissionOverlay.style.display === 'none') {
                     setTimeout(() => { if (loadingScreen) loadingScreen.style.display = 'none'; }, 300); 
                }
            }
        });
    </script>
</body>
</html>