<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Garden - Debug No Flowers (Step 1)</title> <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r132/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/js/controls/DeviceOrientationControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.0/examples/js/renderers/CSS2DRenderer.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Gwendolyn:wght@700&family=Roboto:wght@400;700&display=swap"
        rel="stylesheet">

    <style>
        /* --- CSS styles remain the same --- */
        body { margin: 0; padding: 0; font-family: 'Roboto', Arial, sans-serif; overflow: hidden; background-color: #000; }
        #loading { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: white; display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 3000; text-align: center; padding: 20px; box-sizing: border-box; }
        #loading h1 { font-family: 'Roboto', sans-serif; font-weight: 700; font-size: 2.5em; margin-bottom: 15px; }
        #loading p { font-size: 1.1em; margin-bottom: 20px; }
        #camera-feed { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 1; }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }
        #css2d-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 3; pointer-events: none; }
        .css2d-interactive { pointer-events: auto; }
        #message-container { color: white; background: none; padding: 5px; text-align: center; font-family: 'Gwendolyn', cursive; font-weight: 700; font-size: 30vw; line-height: 1.1; pointer-events: auto; text-shadow: 1px 1px 2px rgba(0,0,0,0.7), 2px 2px 5px rgba(0,0,0,0.5); white-space: normal; max-width: 90%; box-sizing: border-box; }
        .dynamic-response-display { color: #C8FFC5; background-color: rgba(0,0,0,0.65); padding: 8px 12px; border-radius: 8px; text-align: center; font-family: 'Roboto', sans-serif; font-size: 15px; font-weight: 400; pointer-events: auto; max-width: 250px; box-sizing: border-box; text-shadow: 1px 1px 2px rgba(0,0,0,0.4); }
        .controls { position: fixed; bottom: 20px; width: 100%; display: flex; justify-content: space-around; padding: 0 20px; box-sizing: border-box; z-index: 100; }
        .btn { width: 60px; height: 60px; border-radius: 50%; color: white; border: none; font-family: 'Roboto', sans-serif; font-size: 28px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(0,0,0,0.4); cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease; }
        #place-btn { background-color: #4CAF50; }
        #reset-btn { background-color: #f44336; display: none; }
        #response-toggle { background-color: #2196F3; display: none; }
        #response-form { position: fixed; bottom: 90px; left: 50%; transform: translateX(-50%); width: 90%; max-width: 400px; background: rgba(20,20,20,0.85); backdrop-filter: blur(5px); border-radius: 15px; padding: 20px; color: white; z-index: 200; display: none; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        #response-form input, #response-form textarea { width: calc(100% - 20px); padding: 10px; margin: 8px 0 12px; border: 1px solid #555; border-radius: 5px; background: rgba(255,255,255,0.1); color: white; font-size: 16px; }
        #response-form textarea { height: 80px; resize: none; }
        #response-form button { background: #4CAF50; color: white; border: none; padding: 12px 18px; border-radius: 5px; cursor: pointer; font-weight: bold; width: 100%; font-size: 16px; }
        #response-form h3 { margin-top: 0; text-align: center; font-weight: 700;}
        #response-status { margin-top: 12px; text-align: center; font-weight: bold; min-height: 20px; }
        #instructions { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.75); backdrop-filter: blur(3px); color: white; padding: 12px 18px; border-radius: 10px; text-align: center; font-size: 16px; z-index: 100; max-width: 80%; }
        #permission-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.9); z-index: 4000; display: none; flex-direction: column; justify-content: center; align-items: center; text-align: center; color: white; padding: 20px; }
        #permission-overlay h2 { font-weight: 700; }
        #permission-btn { margin-top: 20px; padding: 12px 24px; background-color: #4CAF50; color: white; border: none; border-radius: 30px; font-size: 18px; font-weight: 700; cursor: pointer; }
        #debug-info { position: fixed; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: #0f0; padding: 8px 12px; border-radius: 5px; font-size: 11px; font-family: monospace; z-index: 2500; display: none; width: calc(100% - 40px); max-height: 150px; overflow-y: auto; }
    </style>

    <script id="flowerVertexShader" type="x-shader/x-vertex">
        // --- Vertex Shader is UNCHANGED from the previous working version ---

        // Custom uniforms (declare ONLY these)
        uniform float u_time;

        // Custom instanced attributes (declare ONLY these)
        in vec2 instanceRandomVec2;      
        in float instanceStemGrowTime;   
        in float instanceFlowerGrowTime; 

        // Varyings to pass to fragment shader (declare these)
        out vec2 vUv;
        out float vTime;
        out vec2 vRandomVec2;
        out float vStemGrowTime;
        out float vFlowerGrowTime;
        out float vFragDepth;

        void main() {
            vUv = uv; // Read standard attribute
            vTime = u_time; 
            
            vRandomVec2 = instanceRandomVec2;
            vStemGrowTime = instanceStemGrowTime;
            vFlowerGrowTime = instanceFlowerGrowTime;

            vec3 pos = position; // Use standard attribute

            // Gentle sway animation
            float wiggleFactor = vStemGrowTime * (0.03 + vRandomVec2.x * 0.03);
            pos.x += sin(vTime * (0.8 + vRandomVec2.y * 0.4) + pos.y * 0.6) * wiggleFactor;
            pos.y += cos(vTime * (0.7 + vRandomVec2.x * 0.3) + pos.x * 0.4) * wiggleFactor * 0.7;

            // Use standard uniforms 
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_Position = projectionMatrix * mvPosition;
            
            vFragDepth = gl_Position.z / gl_Position.w;
        }
    </script>

    <script id="flowerFragmentShader" type="x-shader/x-fragment">
        // --- Fragment Shader SIMPLIFIED for debugging ---

        // Varyings received from vertex shader (declare these)
        in vec2 vUv; // Still needed to know *where* to draw
        // Other varyings (vTime, vRandomVec2, etc.) are not needed for this simple test

        // Use the automatically provided output variable via the #define
        #define gl_FragColor pc_fragColor

        void main() {
            // --- DEBUG STEP 1: Output solid magenta color ---
            // Ignore all previous logic for drawing stems/flowers/transparency.
            // Just output an opaque color for every fragment.
            gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); // Magenta, Alpha = 1.0 (Opaque)
        }
    </script>
</head>

<body>
    <div id="loading"><h1>Why can't...?</h1><p>Loading experience...</p></div>
    <div id="permission-overlay"><h2>Motion Sensors Required</h2><p>This AR experience needs access to your device's motion sensors to look around.</p><button id="permission-btn">Allow Motion Sensors</button></div>
    <video id="camera-feed" autoplay playsinline muted></video>
    <div id="canvas-container"></div>
    <div id="message-container" style="display: none;"><p id="message-text">Why can't this be a community garden?</p></div>
    <div id="response-display-template" style="display: none;"><div class="dynamic-response-display"></div></div>
    <div id="instructions">Tap ðŸŒ¸ to experience the garden, then look around.</div>
    <div class="controls"><button id="response-toggle" class="btn" title="Share thoughts">+</button><button id="place-btn" class="btn" title="Place Garden">ðŸŒ¸</button><button id="reset-btn" class="btn" title="Reset Garden">â†º</button></div>
    <div id="response-form"><h3>Share Your Thoughts</h3><form id="garden-response-form"><label for="name">Your Name:</label><input type="text" id="name" name="name" placeholder="e.g., Alex P." required><label for="form-message">Why can't this be a community garden?</label><textarea id="form-message" name="message" placeholder="Your ideas..." required></textarea><button type="submit">Submit Idea</button></form><div id="response-status"></div></div>
    <div id="debug-info"></div>

    <script type="module">
        // --- All JavaScript code remains the same as the previous version ---
        document.addEventListener('DOMContentLoaded', function () {
            console.log("DOM Content Loaded - Debugging UI & Responses V2 - Debug Step 1 (Solid Color)"); // Updated log message

            let debugInfo = null;
            const loadingScreen = document.getElementById('loading');
            const permissionOverlay = document.getElementById('permission-overlay');
            const permissionBtn = document.getElementById('permission-btn');
            const cameraFeed = document.getElementById('camera-feed');
            const canvasContainer = document.getElementById('canvas-container');
            const instructions = document.getElementById('instructions');
            const placeBtn = document.getElementById('place-btn');
            const resetBtn = document.getElementById('reset-btn');
            const responseToggle = document.getElementById('response-toggle');
            const responseFormParent = document.getElementById('response-form');
            const messageElement = document.getElementById('message-container'); 

            debugInfo = document.getElementById('debug-info');

            let scene, camera, renderer, controls, css2dRenderer, clock;
            let messageObject; 
            let activeResponseObjects = []; 
            const MAX_VISIBLE_RESPONSES = 4;
            let isPlaced = false;

            let instancedFlowers;
            const MAX_FLOWERS = 2500; 
            let currentFlowerCount = 0; 

            let instanceStemGrowTimes = new Float32Array(MAX_FLOWERS);
            let instanceFlowerGrowTimes = new Float32Array(MAX_FLOWERS);
            let instanceRandomVec2s = new Float32Array(MAX_FLOWERS * 2); 
            let instanceStemGrowDuration = new Float32Array(MAX_FLOWERS); 
            let instanceFlowerGrowDuration = new Float32Array(MAX_FLOWERS); 
            let instanceIsBlooming = new Array(MAX_FLOWERS).fill(false); 
            
            const dummy = new THREE.Object3D(); 

            const urlParams = new URLSearchParams(window.location.search);
            const debugMode = urlParams.has('debug');

            if (debugMode) { if (debugInfo) debugInfo.style.display = 'block'; else console.warn("debugInfo element not found for overlay."); }
            else { if (debugInfo) debugInfo.style.display = 'none'; }

            function simpleLog(message) { if (debugMode && debugInfo) { debugInfo.innerHTML += message + '<br>'; debugInfo.scrollTop = debugInfo.scrollHeight; } console.log("SLOG:", message); }
            
            const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;

            simpleLog("About to call initAR()");
            initAR();

            function initAR() { 
                simpleLog('initAR: Called');
                startCamera();
                if (isIOS && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    simpleLog("initAR: iOS path - requesting motion sensor permission.");
                    permissionOverlay.style.display = 'flex';
                    permissionBtn.addEventListener('click', requestMotionPermission, { once: true });
                } else {
                    simpleLog("initAR: Non-iOS or permission not needed / already granted path.");
                    if (loadingScreen) loadingScreen.style.display = 'none';
                    initThree();
                }
            }
            function requestMotionPermission() { 
                 simpleLog("requestMotionPermission: Called");
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === 'granted') {
                        simpleLog("requestMotionPermission: GRANTED");
                        permissionOverlay.style.display = 'none';
                        if (loadingScreen) loadingScreen.style.display = 'none';
                        initThree();
                    } else {
                        simpleLog("requestMotionPermission: DENIED");
                        alert('Motion sensor access is required for this AR experience. Please reload and grant permission.');
                        if (loadingScreen) loadingScreen.innerHTML = '<p>Motion sensor access denied. Please reload the page and grant permission.</p>';
                    }
                }).catch(error => {
                    console.error('requestMotionPermission: ERROR', error);
                    alert('An error occurred while requesting motion sensor access.');
                    if (loadingScreen) loadingScreen.innerHTML = '<p>Error requesting motion sensors. Please reload.</p>';
                });
            }
            function startCamera() { 
                 simpleLog("startCamera: Called");
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    alert('Camera access is not supported by your browser.');
                    if (loadingScreen) loadingScreen.innerHTML = '<p>Camera not supported.</p>';
                    simpleLog("startCamera: Camera access not supported.");
                    return;
                }
                navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment', width: { ideal: window.innerWidth }, height: { ideal: window.innerHeight } } })
                    .then(stream => {
                        simpleLog("startCamera: getUserMedia SUCCEEDED");
                        cameraFeed.srcObject = stream;
                        cameraFeed.onloadedmetadata = () => {
                            simpleLog('startCamera: Camera feed active and playing.');
                            cameraFeed.play();
                        };
                    }).catch(err => {
                        simpleLog("startCamera: getUserMedia FAILED: " + err.message);
                        console.error('startCamera: ERROR:', err);
                        alert("Could not access the camera: " + err.message + ". Please check browser permissions and reload.");
                        if (loadingScreen) loadingScreen.innerHTML = '<p>Camera access failed. Please check permissions and reload.</p>';
                    });
            }

            function initThree() { 
                 simpleLog("initThree: START");
                try {
                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(0, 1.6, 0); 

                    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    renderer.setClearColor(0x000000, 0); 
                    canvasContainer.appendChild(renderer.domElement);

                    css2dRenderer = new THREE.CSS2DRenderer();
                    css2dRenderer.setSize(window.innerWidth, window.innerHeight);
                    css2dRenderer.domElement.id = 'css2d-container'; 
                    document.body.appendChild(css2dRenderer.domElement);


                    controls = new THREE.DeviceOrientationControls(camera);
                    clock = new THREE.Clock();

                    const ambientLight = new THREE.AmbientLight(0xffffff, 0.9); 
                    scene.add(ambientLight);
                    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); 
                    directionalLight.position.set(1, 3, 2);
                    scene.add(directionalLight);

                    const baseFlowerGeometry = createBaseFlowerGeometry(); 
                    const baseFlowerMaterial = createBaseFlowerMaterial(); // <<< Uses the simplified FS
                    
                    instancedFlowers = new THREE.InstancedMesh(baseFlowerGeometry, baseFlowerMaterial, MAX_FLOWERS);
                    instancedFlowers.instanceMatrix.setUsage(THREE.DynamicDrawUsage); 

                    instancedFlowers.geometry.setAttribute('instanceRandomVec2', new THREE.InstancedBufferAttribute(instanceRandomVec2s, 2));
                    instancedFlowers.geometry.setAttribute('instanceStemGrowTime', new THREE.InstancedBufferAttribute(instanceStemGrowTimes, 1));
                    instancedFlowers.geometry.setAttribute('instanceFlowerGrowTime', new THREE.InstancedBufferAttribute(instanceFlowerGrowTimes, 1));
                    
                    instancedFlowers.count = 0; 
                    scene.add(instancedFlowers);
                    simpleLog("initThree: InstancedFlowers mesh created: " + (!!instancedFlowers));

                    createCSS2DObjects(); 
                    window.addEventListener('resize', onWindowResize);
                    animate();
                    simpleLog("initThree: COMPLETED SUCCESSFULLY");

                } catch (error) {
                    console.error("initThree: CRITICAL ERROR:", error);
                    simpleLog("initThree: CRITICAL ERROR: " + error.message);
                    alert("A critical error occurred setting up the 3D scene: " + error.message);
                }
            }
            function createBaseFlowerGeometry() { 
                const s = 1.8;
                return new THREE.PlaneGeometry(s, s); 
            }
            function createBaseFlowerMaterial() { 
                 const uniforms = {
                    u_time: { value: 0.0 },
                };
                return new THREE.ShaderMaterial({
                    uniforms: uniforms,
                    vertexShader: document.getElementById('flowerVertexShader').textContent, 
                    fragmentShader: document.getElementById('flowerFragmentShader').textContent, // Reads SIMPLIFIED shader
                    transparent: true, // Keep true for now, though output is opaque
                    side: THREE.DoubleSide, 
                    depthWrite: false, // Keep false for now
                });
            }
            function createCSS2DObjects() { 
                 simpleLog("createCSS2DObjects: Called");
                if (!messageElement) { console.error('CSS2DObjects: messageElement (for large text) not found!'); return; }
                
                messageObject = new THREE.CSS2DObject(messageElement);
                messageObject.position.set(0, 1.8, -4.0); 
                scene.add(messageObject);
                messageObject.visible = false; 
            }
            function placeFlowers() { 
                simpleLog("placeFlowers: Called (InstancedMesh version)");
                if (!instancedFlowers) { console.error("placeFlowers: InstancedMesh not ready."); return; }

                currentFlowerCount = MAX_FLOWERS / 2; 
                simpleLog(`placeFlowers: Attempting to place ${currentFlowerCount} flowers.`);

                const minDistance = 1.5; const maxDistance = 18.0;
                const minHeight = -2.0; const maxHeight = 1.5; 

                instanceIsBlooming.fill(false);
                instanceStemGrowTimes.fill(0);
                instanceFlowerGrowTimes.fill(0);
                instanceRandomVec2s.fill(0);
                instanceStemGrowDuration.fill(1.0); 
                instanceFlowerGrowDuration.fill(2.0);


                for (let i = 0; i < currentFlowerCount; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = minDistance + Math.random() * (maxDistance - minDistance);
                    const x = Math.cos(angle) * distance;
                    const z = Math.sin(angle) * distance;
                    const y = (camera.position.y - 1.6) + (minHeight + Math.random() * (maxHeight - minHeight));

                    dummy.position.set(x, y, z);
                    dummy.rotation.set(0, Math.random() * Math.PI * 2, 0); 
                    const scaleVariation = 0.5 + Math.random() * 0.7; 
                    dummy.scale.set(scaleVariation, scaleVariation, scaleVariation);
                    dummy.updateMatrix(); 
                    instancedFlowers.setMatrixAt(i, dummy.matrix);

                    instanceRandomVec2s[i * 2 + 0] = Math.random(); 
                    instanceRandomVec2s[i * 2 + 1] = Math.random(); 
                    
                    instanceStemGrowTimes[i] = 0.0;   
                    instanceFlowerGrowTimes[i] = 0.0; 

                    instanceStemGrowDuration[i] = 0.8 + Math.random() * 0.4; 
                    instanceFlowerGrowDuration[i] = instanceStemGrowDuration[i] + (0.7 + Math.random() * 0.6); 

                    setTimeout(() => {
                        if (i < instancedFlowers.count) { 
                           instanceIsBlooming[i] = true;
                        }
                    }, 100 + Math.random() * 2500); 
                }

                instancedFlowers.instanceMatrix.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceRandomVec2) instancedFlowers.geometry.attributes.instanceRandomVec2.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceStemGrowTime) instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                if (instancedFlowers.geometry.attributes.instanceFlowerGrowTime) instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                
                instancedFlowers.count = currentFlowerCount; 
                simpleLog(`placeFlowers: Placed and set count for ${currentFlowerCount} flowers.`);
            }
            function removeFlowers() { 
                 if (instancedFlowers) {
                    simpleLog(`removeFlowers: Hiding ${instancedFlowers.count} flowers by setting count to 0.`);
                    instancedFlowers.count = 0;
                    instancedFlowers.instanceMatrix.needsUpdate = true; 
                    
                    instanceIsBlooming.fill(false);
                    instanceStemGrowTimes.fill(0.0); 
                    instanceFlowerGrowTimes.fill(0.0);

                    if (instancedFlowers.geometry.attributes.instanceStemGrowTime) instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                    if (instancedFlowers.geometry.attributes.instanceFlowerGrowTime) instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;

                    currentFlowerCount = 0;
                }
            }
            function placeDynamicResponses() { 
                 simpleLog("placeDynamicResponses: Called");
                if (!window.responses || window.responses.length === 0) {
                    simpleLog("placeDynamicResponses: No responses available to display.");
                    return;
                }
                removeDynamicResponses(); 

                const numToShow = Math.min(MAX_VISIBLE_RESPONSES, window.responses.length);
                const shuffledResponses = [...window.responses].sort(() => 0.5 - Math.random()); 
                simpleLog(`placeDynamicResponses: Preparing to show ${numToShow} responses.`);

                const responseTemplate = document.getElementById('response-display-template');
                if (!responseTemplate) {
                    console.error("placeDynamicResponses: response-display-template not found!");
                    simpleLog("placeDynamicResponses: ERROR - response-display-template not found!");
                    return;
                }

                for (let i = 0; i < numToShow; i++) {
                    const responseData = shuffledResponses[i];
                    const responseDiv = responseTemplate.firstElementChild.cloneNode(true); 
                    responseDiv.textContent = `"${responseData.message}" - ${responseData.name}`;
                    
                    const newResponseObject = new THREE.CSS2DObject(responseDiv);
                    
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 2.5 + Math.random() * 2.5; 
                    const responseX = Math.cos(angle) * distance;
                    const responseZ = Math.sin(angle) * distance;
                    const responseY = (camera.position.y - 0.5) + Math.random(); 

                    newResponseObject.position.set(responseX, responseY, responseZ);
                    newResponseObject.visible = true; 
                    scene.add(newResponseObject);
                    activeResponseObjects.push(newResponseObject);
                    simpleLog(`placeDynamicResponses: Created CSS2DObject for response "${responseData.message}"`);
                }
                simpleLog(`placeDynamicResponses: Displayed ${activeResponseObjects.length} responses.`);
            }
            function removeDynamicResponses() { 
                 simpleLog(`removeDynamicResponses: Removing ${activeResponseObjects.length} dynamic response objects.`);
                activeResponseObjects.forEach(obj => {
                    if (obj.element && obj.element.parentNode) {
                        // obj.element.parentNode.removeChild(obj.element); 
                    }
                    scene.remove(obj); 
                });
                activeResponseObjects = [];
            }
            function updateFlowerAnimations(delta, elapsedTime) { 
                if (!instancedFlowers || instancedFlowers.count === 0) return;

                instancedFlowers.material.uniforms.u_time.value = elapsedTime;

                let needsStemUpdate = false;
                let needsFlowerUpdate = false;

                for (let i = 0; i < instancedFlowers.count; i++) {
                    if (instanceIsBlooming[i]) { 
                        if (instanceStemGrowTimes[i] < 1.0) {
                            instanceStemGrowTimes[i] += delta / instanceStemGrowDuration[i];
                            instanceStemGrowTimes[i] = Math.min(instanceStemGrowTimes[i], 1.0);
                            needsStemUpdate = true;
                        }

                        if (instanceStemGrowTimes[i] >= 1.0 && instanceFlowerGrowTimes[i] < 1.0) {
                            let flowerPhaseDuration = instanceFlowerGrowDuration[i] - instanceStemGrowDuration[i];
                            if (flowerPhaseDuration <= 0) flowerPhaseDuration = delta; 

                            instanceFlowerGrowTimes[i] += delta / flowerPhaseDuration;
                            instanceFlowerGrowTimes[i] = Math.min(instanceFlowerGrowTimes[i], 1.0);
                            needsFlowerUpdate = true;
                        }
                    }
                }

                // Log update status once per frame if updates are happening
                if(needsStemUpdate || needsFlowerUpdate){
                    //simpleLog(`Update Frame: stemNeedsUpdate=${needsStemUpdate}, flowerNeedsUpdate=${needsFlowerUpdate}, FirstFlowerTimes: stem=${instanceStemGrowTimes[0]?.toFixed(2)}, flower=${instanceFlowerGrowTimes[0]?.toFixed(2)}`);
                }


                if (needsStemUpdate && instancedFlowers.geometry.attributes.instanceStemGrowTime) {
                    //simpleLog("Setting needsUpdate=true for instanceStemGrowTime"); 
                    instancedFlowers.geometry.attributes.instanceStemGrowTime.array[0] = instanceStemGrowTimes[0]; 
                    instancedFlowers.geometry.attributes.instanceStemGrowTime.needsUpdate = true;
                }
                if (needsFlowerUpdate && instancedFlowers.geometry.attributes.instanceFlowerGrowTime) {
                    //simpleLog("Setting needsUpdate=true for instanceFlowerGrowTime");
                    instancedFlowers.geometry.attributes.instanceFlowerGrowTime.array[0] = instanceFlowerGrowTimes[0]; 
                    instancedFlowers.geometry.attributes.instanceFlowerGrowTime.needsUpdate = true;
                }
            }
            function animate() { 
                 requestAnimationFrame(animate);
                if (controls) controls.update();
                if (!clock) return;

                const delta = clock.getDelta();
                const elapsedTime = clock.getElapsedTime();

                if (isPlaced) {
                    updateFlowerAnimations(delta, elapsedTime); 

                    if (instancedFlowers && instancedFlowers.count > 0) {
                        const camPos = camera.position;
                        for (let i = 0; i < instancedFlowers.count; i++) {
                            instancedFlowers.getMatrixAt(i, dummy.matrix);
                            dummy.matrix.decompose(dummy.position, dummy.quaternion, dummy.scale);
                            dummy.lookAt(camPos); 
                            dummy.updateMatrix();
                            instancedFlowers.setMatrixAt(i, dummy.matrix);
                        }
                        instancedFlowers.instanceMatrix.needsUpdate = true;
                    }
                }
                
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                } else {
                    simpleLog("animate: renderer, scene, or camera missing!");
                }

                if (css2dRenderer && scene && camera) {
                    css2dRenderer.render(scene, camera);
                }
            }
            function onWindowResize() { 
                if (camera && renderer && css2dRenderer) {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    css2dRenderer.setSize(window.innerWidth, window.innerHeight);
                    // simpleLog("onWindowResize: Updated camera and renderers."); // Less noisy log
                }
            }
            
            // --- UI Listeners & Response Handling... same as before ... ---
            if (!placeBtn) { console.error("CRITICAL ERROR: placeBtn element not found!"); }
            else { /* ... placeBtn listener ... */ 
                simpleLog("Attaching listener to placeBtn.");
                placeBtn.addEventListener('click', function () {
                    simpleLog("placeBtn: CLICKED.");
                    if (isPlaced) { simpleLog(`placeBtn: Garden already placed.`); return; }
                    if (!instancedFlowers || !scene || !camera) {
                        console.error('placeBtn: CRITICAL - Prerequisite Three.js objects (instancedFlowers, scene, camera) not ready!');
                        simpleLog('placeBtn: ERROR - Prerequisite objects not ready!');
                        alert("The garden components are not ready yet. Please wait or reload.");
                        return;
                    }
                    
                    if (messageObject && messageObject.element) {
                        messageObject.visible = true;
                        messageElement.style.display = 'block'; 
                    } else {
                        simpleLog("placeBtn: messageObject or its element not ready to be shown.");
                    }

                    placeBtn.style.display = 'none';
                    resetBtn.style.display = 'flex';
                    responseToggle.style.display = 'flex';
                    instructions.style.display = 'none';
                    
                    placeFlowers(); 
                    isPlaced = true;
                    loadResponses(true); 
                    simpleLog('placeBtn: Garden PLACED with instanced flowers.');
                });
            }
            if (!resetBtn) { console.error("CRITICAL ERROR: resetBtn element not found!"); }
            else { /* ... resetBtn listener ... */ 
                simpleLog("Attaching listener to resetBtn.");
                resetBtn.addEventListener('click', function () {
                    simpleLog("resetBtn: CLICKED");
                    if (!isPlaced) { simpleLog("resetBtn: Nothing to reset, garden not placed."); return; }
                    
                    if (messageObject && messageObject.element) {
                        messageObject.visible = false;
                        messageElement.style.display = 'none';
                    }
                    removeDynamicResponses(); 
                    
                    resetBtn.style.display = 'none';
                    placeBtn.style.display = 'flex';
                    responseToggle.style.display = 'none';
                    if (responseFormParent) responseFormParent.style.display = 'none'; 
                    
                    instructions.style.display = 'block';
                    removeFlowers(); 
                    isPlaced = false;
                    simpleLog('resetBtn: Garden RESET.');
                });
            }
            if (!responseToggle) { console.error("CRITICAL ERROR: responseToggle element not found!"); }
            else { /* ... responseToggle listener ... */ 
                 simpleLog("Attaching listener to responseToggle.");
                responseToggle.addEventListener('click', function () {
                    simpleLog("responseToggle: CLICKED");
                    if (!responseFormParent) { console.error("responseToggle: responseFormParent (div#response-form) not found!"); return; }
                    const isFormVisible = responseFormParent.style.display === 'block';
                    responseFormParent.style.display = isFormVisible ? 'none' : 'block';
                    responseToggle.textContent = isFormVisible ? 'âœ•' : '+'; 
                    simpleLog(`responseToggle: Form display set to ${responseFormParent.style.display}`);
                });
            }
            
             window.responses = [ /* ... mock data ... */ 
                { name: "Gardener A", message: "More native plants, please!" },
                { name: "Bee Lover", message: "We need pollinator-friendly species." },
                { name: "Artist X", message: "A sculpture would look great here." },
                { name: "Kiddo", message: "Can we have a fairy garden part?" },
                { name: "Community Member", message: "A bench to sit would be nice." }
             ];
            function loadResponses(isInitialPlacement = false) { 
                 simpleLog(`loadResponses: Called. isInitialPlacement: ${isInitialPlacement}`);
                if (isPlaced) { 
                    placeDynamicResponses();
                }
            }
            const gardenResponseForm = document.getElementById('garden-response-form');
            if (!gardenResponseForm) { console.error("CRITICAL ERROR: garden-response-form element not found!"); }
            else { /* ... form submit listener ... */ 
                gardenResponseForm.addEventListener('submit', function (e) {
                    e.preventDefault();
                    simpleLog("gardenResponseForm: SUBMITTED");
                    const nameInput = document.getElementById('name');
                    const messageInput = document.getElementById('form-message');
                    const statusDiv = document.getElementById('response-status');

                    if (!nameInput || !messageInput || !statusDiv) {
                        console.error("Form submission: Name, message input, or status div not found.");
                        simpleLog("Form submission: ERROR - form elements missing.");
                        return;
                    }

                    const name = nameInput.value.trim();
                    const message = messageInput.value.trim();

                    if (name && message) {
                        simpleLog(`Form data: Name: ${name}, Message: ${message}`);
                        window.responses.push({ name: name, message: message });
                        statusDiv.textContent = "Idea submitted! Thank you!";
                        statusDiv.style.color = "#4CAF50";
                        
                        nameInput.value = '';
                        messageInput.value = '';
                        if(isPlaced) placeDynamicResponses(); 

                        setTimeout(() => { 
                            statusDiv.textContent = ""; 
                            if (responseFormParent) responseFormParent.style.display = 'none'; 
                            responseToggle.textContent = '+';
                        }, 2500);
                    } else {
                        statusDiv.textContent = "Please fill out both fields.";
                        statusDiv.style.color = "#f44336";
                        simpleLog("Form submission: Fields not filled.");
                    }
                });
            }

            if (!isIOS || (isIOS && typeof DeviceOrientationEvent.requestPermission !== 'function')) { 
                if (permissionOverlay.style.display === 'none') {
                     setTimeout(() => { if (loadingScreen) loadingScreen.style.display = 'none'; }, 300); 
                }
            }
        });
    </script>
</body>
</html>